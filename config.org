* Installation
Clone into the =.emacs.d= folder created by Emacs
#+BEGIN_SRC 
git clone git@github.com:blemberger-b/emacs-config.git ~/.emacs.d
#+END_SRC
When Emacs is opened, it will download the specified packages (with their dependencies) and
apply the customizations from *init.el* and this file.
* Custom Packages & Modes
These packages here and elsewhere are installed via [[https://github.com/jwiegley/use-package][use-package]]. From time to time, you should check
for updates using the command =M-x package-list-packages=, which will tell you which packages have
updates available and prompt to upgrade them.
*** Install & use =paradox= for package listing
	 A better tool to use for listing and updating packages than the default =list-packages=. See the
	 [[https://github.com/Malabarba/paradox][project page]] for more info.
	 #+begin_src emacs-lisp
		(use-package paradox
		  :ensure t
		  :config (paradox-enable))
	 #+end_src
*** Install & use =sudo-edit= (from MELPA)
=sudo-edit= allows editing write protected files by first doing =sudo= before visting the file
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind ("s-e" . sudo-edit))
#+END_SRC
*** Recent Files
	 Emacs does not keep track of recently found files by default, so turn it on, and set some
	 reasonable defaults.
	 #+begin_src emacs-lisp
		(use-package recentf
		  :ensure t
		  :config
		  (setq recentf-max-saved-items 100
				  recentf-exclude '("ido.last"))
		  (recentf-mode 1))
	 #+end_src
*** Dashboard
The =dashboard= package allows setting a better initial buffer when Emacs opens. See
[[https://github.com/emacs-dashboard/emacs-dashboard][here]] for info and configuration values. Also, here we
are excluding files from the recent files list that get treated as edited by the package manager for some reason.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :pin melpa-stable
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-items '((recents . 10)))
    (setq dashboard-banner-logo-title
	  "The more I learn about people, the more I like my dog\t--Mark Twain")
    (setq dashboard-set-footer nil)
    (setq recentf-exclude '(".*autoloads\.el" ".*\.gz")))
#+END_SRC
*** Install & use =markdown-mode= (from MELPA)
This package provides a major mode for editing markdown files. It requires the =markdown= command be installed via homebrew.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/markdown"))
#+END_SRC
*** Install & use =yaml-mode=
Allows efficient editing of YAML files.
#+begin_src emacs-lisp
	 (use-package yaml-mode
		:ensure t
		:commands (yaml-mode))
#+end_src
*** Presentation Mode
This minor mode allows increasing/decreasing the font size in /all/ buffers. It can be run
on-demand: =M-x presentation-mode=. See [[https://github.com/zonuexe/emacs-presentation-mode][here]].
#+BEGIN_SRC emacs-lisp
  (use-package presentation
    :ensure t
    :pin melpa-stable)
#+END_SRC
* Global Settings
*** Install & run =exec-path-from-shell=
On OS X, an Emacs instance started from the graphical user interface will have a different
environment than a shell in a terminal window, because OS X does not run a shell during the login.
Obviously this will lead to unexpected results when calling external utilities like *make* from
Emacs. This library works around this problem by copying important environment variables from the
user's shell. See [[https://github.com/purcell/exec-path-from-shell][here]].
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init (when (memq window-system '(mac ns x))
	    (exec-path-from-shell-initialize)))
#+END_SRC

*** Turn off emacs start screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Turn off aggressive vertical scrolling
#+BEGIN_SRC  emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

*** Turn off annoying bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Turn off auto-saving
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

*** Backup files go in a dedicated directory
Emacs can automatically create backup files. This tells Emacs to put all backups in
~/.emacs.d/backups. More info [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][here]].
#+begin_src emacs-lisp
	(setq backup-directory-alist `(("." . ,
																	(concat user-emacs-directory "backups"))))
#+end_src

*** Set default fill column
Set the default column to 100 where emacs will attempt to auto-fill in those modes that support it.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 100)
#+END_SRC

*** No tab characters
Make indentation use space characters only and not tab characters. Note that some major modes
override this behavior.
#+begin_src emacs-lisp
	(setq-default indent-tabs-mode nil)
#+end_src

*** Set default tab width
Set the number of spaces corresponding to a tab character, unless overridden by buffers or modes.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src
*** Turn off =electric-indent-mode=
	 #+begin_src emacs-lisp
		(setq electric-indent-mode nil)
	 #+end_src
*** Replace 'yes-or-no' prompts everywhere with 'y-or-n' prompts
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Set directory listing options
Both verbose and brief directory listings using =C-x C-d= should list hidden as well as visible
files.
#+begin_src emacs-lisp
  (setq list-directory-brief-switches "-la")
  (setq list-directory-verbose-switches "-CFa")
#+end_src
*** Remap Mac Fn key to super key =(s- )=
Doesn't work in tty mode, must use =C-x @ s= and then the key.
#+BEGIN_SRC emacs-lisp
  (setq mac-function-modifier 'super)
#+END_SRC
*** Fix some stupid failed binding to =backtab= key in Mac OS console mode
See [[https://stackoverflow.com/questions/3518846/shift-tab-produces-cryptic-error-in-emacs][this explanation]].
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-setup-hook
	    (lambda () (define-key input-decode-map "\e[Z" [backtab])))
#+END_SRC
*** iterm2 Mac OS console mode fixes
Emacs generally has problems with the Control-Meta-Shift combination key bindings in console
mode. This is due to terminal emulators on all systems, not just Mac OS, not able to process the
escape sequences and pass them through to emacs. Some of these problems can be fixed by modifying
the terminal emulator program to send the expected escape sequences for the desired key-presses that
emacs is expecting. A writeup for how to fix some of these key bindings in Mac OS iterm2 is discussed
[[https://emacs.stackexchange.com/a/45624][here]]. The decimal ASCII codes to be used for whatever bindings
are desired can be looked up in any standard ASCII table.

For example, to map =C-,= in *iterm2* so that it works when emacs is run in console mode, I
configured my iterm2 profile to map =^,= to the escape sequence =[44;5u= since comma is ASCII code 44.
*** Disable 'cl is deprecated warning'
Stupid warning is shown because =cl= is a transitive dependency from other packages. Nothing we can
do until those packages migrate to something other than cl, so we'll just suppress the warning. See [[https://github.com/kiwanami/emacs-epc/issues/35][this]].
#+begin_src emacs-lisp
  (setq byte-compile-warnings '(cl-functions))
#+end_src
*** Save clipboard strings into kill ring before replacing them
	 When one selects something in another program to paste it into Emacs, but kills something in
	 Emacs before actually pasting it, this selection is gone unless this variable is non-nil.
	 #+begin_src emacs-lisp
		(setq save-interprogram-paste-before-kill t)
	 #+end_src
*** Save place in opened files
	 When you visit a file, point goes to the last place where it was when you previously visited the
	 same file. See [[https://www.emacswiki.org/emacs/SavePlace][here]].
	 #+begin_src emacs-lisp
		(save-place-mode 1)
	 #+end_src
*** Hippie expand
	 [[https://www.emacswiki.org/emacs/HippieExpand][hippie-expand]] is a useful built-in function that does abbreviation or word expansion in a
	 buffer. Activate it by invoking =M-/= (this overrides the keybinding for =dabbrev-expand=).
	 #+begin_src emacs-lisp
		(global-set-key (kbd "M-/") 'hippie-expand)
	 #+end_src
	 Also set some locations for =hippie-expand= to look for completions that are particularly
	 useful for editing lisp files:
	 #+begin_src emacs-lisp
		(setq hippie-expand-try-functions-list
				'(try-expand-dabbrev
				  try-expand-dabbrev-all-buffers
				  try-expand-dabbrev-from-kill
				  try-complete-lisp-symbol-partially
				  try-complete-lisp-symbol))
	 #+end_src
*** Toggle whitespace-mode
		=whitespace-mode= is useful for showing whitespace characters on the screen. Togging it on or
		off using =C-c w=.
#+begin_src emacs-lisp
	(global-set-key (kbd "C-c w") 'whitespace-mode)
#+end_src
* UI Customizations
*** Set geometry of all emacs frames on Mac
Top-left corner of initial frame will be 50 pixels down from the top margin and 250 pixels right from the left margin. It also makes the window size 45 x 112 characters.
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((top . 50) (left . 250) (width . 112) (height . 45)))
#+END_SRC
*** Turn off graphical tool-bar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** Turn off native OS scroll bars on window frames
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode)
	 (scroll-bar-mode -1))
#+END_SRC

*** Turn off top menu bar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC

*** Cursor blink
Set the cursor to always blink. This setting has no effect in TTY mode (the cursor always blinks
there).
#+BEGIN_SRC emacs-lisp
  (setq blink-cursor-blinks 0)
#+END_SRC

*** Full path in title bar
	 #+begin_src emacs-lisp
		(setq frame-title-format "%b (%f)")
	 #+end_src
*** Turn on line numbering in all buffers that support it
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC

*** Turn on line highlight mode only in GUI mode
#+BEGIN_SRC emacs-lisp
  (when window-system (global-hl-line-mode))
#+END_SRC

* Minibuffer
*** Install & use =smex= (from MELPA)
This package provides command completion in the minibuffer after typing =M-x=.
#+BEGIN_SRC emacs-lisp
  (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind
       ("M-x" . smex))
#+END_SRC
*** Add =which-key= package
This package provides a pop-up menu of command key completions when keys are pressed interactively
in the minibuffer. We also suppress it from showing up in the modeline. See [[https://github.com/justbur/emacs-which-key][here]].
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode)
    :diminish which-key-mode)
#+END_SRC
* Mode Line
*** Turn on column mode display of (line,col) in mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
*** Spaceline
=spaceline= is a better mode line from the [[https://www.spacemacs.org/][spacemacs distribution]].
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :pin melpa-stable
    :ensure t
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme))
#+END_SRC
*** Diminish minor modes from the modeline
    [[https://github.com/myrjola/diminish.el][diminish]] allows us to list the mode names that we don't want displayed in the modeline. We do
    that here by using the =:diminish= keyword in =use-package= declarations that we want to
    suppress, or by specifing them in the =config:= section.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :pin melpa-stable
    :ensure t
    :config (diminish 'eldoc-mode))
#+END_SRC

* Kill Ring
*** Turn on helpful kill ring pop-up menu and bind it to =M-y=
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Terminal
*** Make bash the default shell for ansi-term
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
*** Bind ansi-term command to =s-t=
Doesn't work in tty mode, must use =C-x @ s t=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-t") 'ansi-term)
#+END_SRC
* Org Mode
*** Edit src snippets in same window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
*** Htmlize
Install =htmlize= package to allow exporting =org-mode= files in html format
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t
    :pin melpa-stable)
#+END_SRC
* Ido Mode
=ido-mode= is a built-in minor mode that lets you "interactively do" things & makes the minibuffer
and most completion buffer features work better.
*** Enable =ido-mode=
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
#+END_SRC
*** Set some default preferences
#+BEGIN_SRC emacs-lisp
  (ido-everywhere t)
  (setq ido-use-faces t)
  (setq ido-enable-flex-matching t)
  (setq ido-create-new-buffer 'always)
  (setq ido-use-filename-at-point nil)
#+END_SRC
*** Install & use =ido-vertical-mode=
This package makes the IDO mode completions in the minibuffer vertical rather than the default horizontal.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init (setq ido-vertical-define-keys 'C-n-and-C-p-only)
	  (ido-vertical-mode 1))
#+END_SRC
* Dired
For directory editing & file system operations within emacs.
*** Enable =dired-x=
Extensions for =dired-mode= that are pre-installed, but not enabled by default, so enable them. For
example, to open all marked files in a dired buffer, type *F* (shift-f).
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-load-hook (lambda () (load "dired-x")))
#+END_SRC
* Config edit/reload
*** Edit this config file
Define a custom function to do this.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
*** Reload configs on demand
Define a custom function to do this.
#+BEGIN_SRC emacs-lisp
    (defun config-reload ()
      (interactive)
      (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC
* Moving Point
*** Move the point to where I really mean to (MWIM)
This package overrides the default beginning/end of line motion actions to more convenient
motion actions for programming modes. It's always on, so hopefully it doesn't interfere with
non-programming modes too much.
#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :ensure t
    :pin melpa-stable
    :bind (("C-a" . mwim-beginning)
	   ("C-e" . mwim-end)))
#+END_SRC

*** Go To Last Change
Use the =C-x C-/= key combination to return to the last edit location in the active buffer.
#+BEGIN_SRC emacs-lisp
  (use-package goto-last-change
    :ensure t
    :pin melpa-stable
    :bind ("C-x C-/" . goto-last-change))
#+END_SRC

*** Install & use =avy= (from MELPA)
This package provides a way to quickly go to a character in the visible buffer by typing a key
binding defined below.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t)
#+END_SRC

* Line Manipulation
*** Copy whole line
Copy the line containing the point to the kill ring.
#+BEGIN_SRC emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'copy-whole-line)
#+END_SRC

* Buffers
*** Bind =ibuffer= to the normal buffer list key
ibuffer is a /better/ interactive buffer list that allows deleting buffers and switching buffers in the same window.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
*** Buffer Move
Package =buffer-move= allows re-arranging buffers within multiple windows in a frame. The
keybindings below conflict with =org-mode=, but they are too damn convenient, so just use
them when not in =org-mode=. "<C-S->" here means Ctrl+Shift+whatever.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :pin melpa-stable
    :bind (("<C-S-up>" . buf-move-up)
	   ("<C-S-down>" . buf-move-down)
	   ("<C-S-right>" . buf-move-right)
	   ("<C-S-left>" . buf-move-left)))
#+END_SRC
*** Always kill the current buffer
Override default emacs and =ido-mode= functionality to prompt for the buffer to kill, and just go
ahead and kill the current one. It will still prompt for confirmation if the buffer is unsaved.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+END_SRC
Bind it to the default =kill-buffer= keybinding =C-x k=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill all buffers
This command will kill all killable buffers. If any buffers have unsaved changes, you'll be prompted
to confirm.
#+BEGIN_SRC emacs-lisp
  (defun kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
#+END_SRC
Bind it to some difficult key combination to press by accident: =C-M-s-k=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-s-k") 'kill-all-buffers)
#+END_SRC
* Windows
*** Split window horizontally & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split horizontally key =C-x 2=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
#+END_SRC
*** Split window vertically & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split vertically key =C-x 3=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
*** Halve other window height
    Tip from [[https://stackoverflow.com/questions/4987760/how-to-change-size-of-split-screen-emacs-windows][here]].
#+BEGIN_SRC emacs-lisp
  (defun halve-other-window-height ()
    "Expand current window to use half of the other window's lines."
    (interactive)
    (enlarge-window (/ (window-height (next-window)) 2)))
#+END_SRC
Bind it to a key.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c v") 'halve-other-window-height)
#+END_SRC
*** Bind more convenient keys to resize windows
*Note:* These override the default bindings for scroll window up/down, etc., but I don't care
because I use =C-v=, =M-v= for that. The arrow keys on Mac keyboards are given in comments next to
each definition below.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<next>") 'shrink-window) ; Fn-down-arrow
  (global-set-key (kbd "<prior>") 'enlarge-window) ; Fn-up-arrow
  (global-set-key (kbd "<home>") 'shrink-window-horizontally) ; Fn-left-arrow
  (global-set-key (kbd "<end>") 'enlarge-window-horizontally)  ; Fn-rigt-arrow
#+END_SRC
* Text Mode
*** =text-mode=
In text mode, you generally want to auto-wrap or "auto-fill" lines of text, so this makes that
happen but only in =text-mode= and its derivatives. We also enable =flyspell-mode= minor mode in all
text modes to get spellchecking functionality, and we bind =M-s= to the go to character function in
the =avy= package (because we don't want to use =avy= in non-text modes).

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda () (turn-on-auto-fill)
			      (flyspell-mode)
			      (local-set-key (kbd "M-s") 'avy-goto-char)))
#+END_SRC
**** Note: This requires that the =ispell= program be installed in the path of the local system.
* XML Mode
*** Turn off flyspell
=nxml-mode= is the modern major mode for editing xml structured documents. It inherits from
=text-mode=, so turning off =flyspell-mode= in order to get completion at point functionality.
#+begin_src emacs-lisp
  (add-hook 'nxml-mode-hook (lambda () (flyspell-mode 0)))
#+end_src
*** Prettify
This creates a keyboard macro that "prettifies" (i.e. re-indents and refomats) XML documents. To run
it, enter =M-x xml-prettify=.
*Note:* This command requires that the *xmllint* command is installed and available in the local
PATH. It comes pre-installed as part of *libxml* on most Mac OS systems.
#+begin_src emacs-lisp
  (fset 'xml-prettify
	  (kmacro-lambda-form [?\C-x ?h ?\C-u ?\M-| ?x ?m ?l ?l ?i ?n ?t ?  ?- ?- ?f ?o ?r ?m ?a ?t ?  ?- return] 0 "%d"))
#+end_src

* Programming Modes
*** =prog-mode= hook
The parent major mode for all programming language modes is =prog-mode=. Here we add the
=subword-mode= minor mode to this mode, which will allow navigation by word commands to respect
camel-case words. In other words, camel-case boundaries of identifiers will form "word" boundaries
in all programming language files with this setting enabled. Also, turn on spell-checking in
comments and literal strings using =flyspell-prog-mode= (This requires that the =ispell= program be
installed in the path of the local system).

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
			      (subword-mode 1)
			      (diminish 'subword-mode)
			      (flyspell-prog-mode)
			      (diminish 'flyspell-mode)))
#+END_SRC

*** Auto-complete
For auto-complete in programming modes, we'll use the [[https://company-mode.github.io/][company package]].
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :pin gnu
    :hook (('prog-mode . company-mode)
	   ('cider-repl-mode . company-mode)))
#+END_SRC

*** Turn on parenthesis matching mode
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** Paredit
This minor mode makes dealing with parenthesis and lisp expressions much easier. Here, we enable it
for some lisp major modes only. Also remap the s-expression /slurp/
and /barf/ commands to keybindings that work in both GUI and TTY.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :pin melpa-stable
    :hook ((clojure-mode
	    emacs-lisp-mode
	    scheme-mode
	    geiser-repl-mode
	    cider-repl-mode) . enable-paredit-mode)
    :bind (("C-c )" . paredit-forward-slurp-sexp)
	   ("C-c (" . paredit-backward-slurp-sexp)
	   ("C-c M-)" . paredit-forward-barf-sexp)
	   ("C-c M-(" . paredit-backward-barf-sexp)))
#+END_SRC

*** Colorful matching delimiters
This package changes the color of corresponding pairs of parenthesis and brackets. Here, we enable
it only in prog-mode and its descendants, and in =cider-repl-mode=.
#+BEGIN_SRC emacs-lisp
	(use-package rainbow-delimiters
		:ensure t
		:pin melpa-stable
		:hook (('prog-mode . rainbow-delimiters-mode-enable)
		 ('cider-repl-mode . rainbow-delimiters-mode-enable))
		)
#+END_SRC

* Clojure
In addition to the above settings, the following settings apply only to editing clojure files and buffers.
*** Set indent mode for clojure buffers
Set the variable =clojure-indent-style= to the value =always-indent=. See [[https://github.com/clojure-emacs/clojure-mode#indentation-options][here]] for more info.
#+BEGIN_SRC emacs-lisp
  (setq clojure-indent-style 'always-indent)
#+END_SRC
*** =clojure-mode= customizations
- =comment-column= set to 0 to not force adding extra space after inline *;*
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook (lambda () (setq-local comment-column 0)))
#+END_SRC

*** Install & use =cider= (from MELPA)
[[https://github.com/clojure-emacs/cider][cider]] is the /clojure integrated development environment/. We're only going to use the melpa stable version.
Initialize some settings, and bind the command to clear the REPL screen to =C-c C-l= key. Also set
the following defaults:
- =cider-repl-display-help-banner= suppress the verbose help banner when opened
- =cider-eldoc-display-context-dependent-info= try to auto-complete function calls with in-scope
  parameters
- =cider-allow-jack-in-without-project= Suppress warning that the REPL gives when you're current
  buffer is not part of a leiningen project.
- =nrepl-log-messages= Log all request/response messages between cider and the =nrepl= server to a
  special buffer for debugging purposes
- =cider-use-overlays= controls whether evaluated results are shown in the original
  buffer. Here, we disable in TTY mode, because the fonts & colors are messy. Results will be on the
  status line.
- =cider-prompt-for-symbol= Here, we set this variable to only prompt for the symbol if the lookup
  for the symbol at point fails.
- =cider-repl-pop-to-buffer-on-connect= Display the REPL buffer on connect, but don't move focus to
  it.
- =cider-repl-wrap-history= Wrap when navigating history.
#+BEGIN_SRC emacs-lisp
	(use-package cider
		:ensure t
		:pin melpa-stable
		:init (setq cider-repl-display-help-banner nil)
		(setq cider-eldoc-display-context-dependent-info t)
		(setq cider-allow-jack-in-without-project t)
		(setq nrepl-log-messages t)
		(setq cider-repl-result-prefix "=> ")
		(unless window-system (setq cider-use-overlays nil))
		(setq cider-prompt-for-symbol nil)
		(setq cider-repl-pop-to-buffer-on-connect 'display-only)
		(setq cider-repl-wrap-history t)
		:bind ("C-c C-l" . cider-repl-clear-buffer))
#+END_SRC

*** =cider-repl-mode=
Major mode for the Cider REPL. Enable subword mode in it, but diminish it.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-repl-mode-hook (lambda ()
			      (subword-mode 1)
			      (diminish 'subword-mode)))
#+END_SRC
* Scheme
*** Install & use =geiser=
=geiser= is a better scheme mode than the built-in =scheme-mode=. Specify =guile= command as the
name of the scheme REPL. [[https://www.gnu.org/software/guile/manual/html_node/index.html#SEC_Contents][guile]] can be installed via *homebrew* or downloaded otherwise. The =guile=
command must be included in the *PATH*.

- =geiser-active-implementations= sets only *guile* to be the scheme language system used by geiser.
- =geiser-repl-query-on-exit-p= sets the REPL to not ask for confirmation on REPL exit.
- =geiser-guile-load-init-file-p= toggles on the option to load the =~/.guile= file before starting
  a guile REPL.

Start a scheme REPL by running the command =M-x run-geiser=.
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :init (setq geiser-active-implementations '(guile))
    (setq geiser-repl-query-on-exit-p nil)
    (setq geiser-guile-load-init-file-p t))
#+END_SRC
* Docker
*** Install & use =dockerfile-mode=
=dockerfile-mode= is a major mode helpful for editing Dockerfiles.
#+begin_src emacs-lisp
  (use-package dockerfile-mode
	 :ensure t
	 :pin melpa-stable)
#+end_src
* Git
*** Install & use =magit=
	 =magit= is a major mode that provides a porcelain layer of tools for the =git= SCM.
#+begin_src emacs-lisp
 (use-package magit
	:ensure t
	:pin melpa-stable)
#+end_src
* Projects
*** Install & use =projectile=
  [[https://docs.projectile.mx/projectile/index.html][projectile]] is a major mode that allows for managing sets of files & buffers that constitute some
  type of /project/, such as git, maven, leiningen, etc. It can auto-discover these types of
  projects, or you can define them yourself.
  #+begin_src emacs-lisp
	 (use-package projectile
		:ensure t
		:pin melpa-stable
		:init (projectile-mode 1)
		:bind (:map projectile-mode-map
						("s-p" . projectile-command-map)
						("C-c p" . projectile-command-map)))
  #+end_src

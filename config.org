#+TITLE: BSL's Customized Emacs
#+AUTHOR: Brian S. Lemberger
#+OPTIONS: toc:1
#+OPTIONS: num:nil

* Installation
Clone into the =.emacs.d= folder created by Emacs
#+BEGIN_SRC 
git clone git@github.com:blemberger-b/emacs-config.git ~/.emacs.d
#+END_SRC
When Emacs is opened, it will download the specified packages (with their dependencies) and
apply the customizations from *init.el* and this file.
* Custom Packages & Modes
These packages here and elsewhere are installed via [[https://github.com/jwiegley/use-package][use-package]]. From time to time, you should check
for updates using the command =M-x package-list-packages=, which will tell you which packages have
updates available and prompt to upgrade them.
*** Install & use =paradox= for package listing
   A better tool to use for listing and updating packages than the default =list-packages=. See the
   [[https://github.com/Malabarba/paradox][project page]] for more info. Setting =paradox-github-token= supposedly turns off the
   starring/unstarring of github repos functionality.
   #+begin_src emacs-lisp
     (use-package paradox
       :ensure t
       :config (paradox-enable)
       :custom (paradox-github-token t))
   #+end_src
*** Install & use =sudo-edit= (from MELPA)
=sudo-edit= allows editing write protected files by first doing =sudo= before visting the file
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind ("s-e" . sudo-edit))
#+END_SRC
*** Recent Files
   Emacs does not keep track of recently found files by default, so turn it on, and set some
   reasonable defaults.
   #+begin_src emacs-lisp
    (use-package recentf
      :ensure t
      :config
      (setq recentf-max-saved-items 100
          recentf-exclude '("ido.last"))
      (recentf-mode 1))
   #+end_src
*** Dashboard
The =dashboard= package allows setting a better initial buffer when Emacs opens. See [[https://github.com/emacs-dashboard/emacs-dashboard][here]] for info
and configuration values. We display recent *projectile* projects and recent files. We exclude files
from the recent files list that get treated as edited by the package manager for some reason.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq recentf-exclude '(".*autoloads\.el" ".*\.gz" "TAGS"))
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-page-separator "\n\f\n")
    (dashboard-projects-backend 'projectile)
    (dashboard-items '((projects . 5)
                       (recents . 10)))
    (dashboard-banner-logo-title
     "The more I learn about people, the more I like my dog\t--Mark Twain")
    (dashboard-set-footer nil))
#+END_SRC
*** Install & use =markdown-mode= (from MELPA)
This package provides a major mode for editing markdown files. It requires the =markdown= command be
installed via homebrew.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
     ("\\.md\\'" . markdown-mode)
     ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/markdown"))
#+END_SRC
*** Install & use =yaml-mode=
Allows efficient editing of YAML files.
#+begin_src emacs-lisp
  (use-package yaml-mode
   :ensure t
   :defer t
   :commands (yaml-mode))
#+end_src
*** Presentation Mode
This minor mode allows increasing/decreasing the font size in /all/ buffers. It can be run
on-demand: =M-x presentation-mode=. See [[https://github.com/zonuexe/emacs-presentation-mode][here]].
#+BEGIN_SRC emacs-lisp
  (use-package presentation
    :ensure t
    :defer t
    :pin melpa-stable)
#+END_SRC
*** Golden ratio screen scrolling
Scroll by 61.8% of the current screen height when using =C-v= and =M-v=.
#+begin_src emacs-lisp
  (use-package golden-ratio-scroll-screen
    :ensure t
    :pin melpa
    :bind (([remap scroll-down-command] . 'golden-ratio-scroll-screen-down)
           ([remap scroll-up-command] . 'golden-ratio-scroll-screen-up)))
#+end_src
*** Better Help
    #+begin_src emacs-lisp
      (use-package helpful
        :pin melpa-stable
        :ensure t
        :bind
        (("C-h f" . helpful-callable) ;; functions & macros
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)
         ("C-h F" . helpful-function) ;; functions only, no macros
         ("C-h C" . helpful-command))) ;; interactive functions only
    #+end_src
* Global Settings
*** Install & run =exec-path-from-shell=
On OS X, an Emacs instance started from the graphical user interface will have a different
environment than a shell in a terminal window, because OS X does not run a shell during the login.
Obviously this will lead to unexpected results when calling external utilities like *make* from
Emacs. This library works around this problem by copying important environment variables from the
user's shell. See [[https://github.com/purcell/exec-path-from-shell][here]].
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

*** Turn off emacs start screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Turn off aggressive vertical scrolling
#+BEGIN_SRC  emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

*** Turn off annoying bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Turn off auto-saving
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

*** Backup files go in a dedicated directory
Emacs can automatically create backup files. This tells Emacs to put all backups in
~/.emacs.d/backups. More info [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][here]].
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,
                                  (concat user-emacs-directory "backups"))))
#+end_src

*** Set default fill column
Set the default column to 100 where emacs will attempt to auto-fill in those modes that support it.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 100)
#+END_SRC

*** No tab characters
Make indentation use space characters only and not tab characters. Note that some major modes
override this behavior.
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** Set default tab width
Set the number of spaces corresponding to a tab character, unless overridden by buffers or modes.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

*** Set =whitespace-mode= highlighting column
The value of this variable determines the column number for lines in buffers viewed in
=whitespace-mode= are shown in highlighted color. =nil= means to use the value of =fill-column=.
 #+begin_src emacs-lisp
   (setq whitespace-line-column nil)
 #+end_src
*** Turn off =electric-indent-mode=
 #+begin_src emacs-lisp
   (setq electric-indent-mode nil)
 #+end_src
*** Tab key behavior regarding indentation
The value of this variable determines how the tab key behaves when struck. This setting only does
indentation when the point is at the beginning of a line.
#+begin_src emacs-lisp
  (setq-default tab-always-indent nil)
#+end_src
*** Replace 'yes-or-no' prompts everywhere with 'y-or-n' prompts
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Set directory listing options
Both verbose and brief directory listings using =C-x C-d= should list hidden as well as visible
files.
#+begin_src emacs-lisp
  (setq list-directory-brief-switches "-la")
  (setq list-directory-verbose-switches "-CFa")
#+end_src
*** Remap Mac Fn key to super key =(s- )=
Doesn't work in tty mode, must use =C-x @ s= and then the key.
#+BEGIN_SRC emacs-lisp
  (setq mac-function-modifier 'super)
#+END_SRC
*** Fix some stupid failed binding to =backtab= key in Mac OS console mode
See [[https://stackoverflow.com/questions/3518846/shift-tab-produces-cryptic-error-in-emacs][this explanation]].
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-setup-hook
      (lambda () (define-key input-decode-map "\e[Z" [backtab])))
#+END_SRC
*** iterm2 Mac OS console mode fixes
Emacs generally has problems with the Control-Meta-Shift combination key bindings in console
mode. This is due to terminal emulators on all systems, not just Mac OS, not able to process the
escape sequences and pass them through to emacs. Some of these problems can be fixed by modifying
the terminal emulator program to send the expected escape sequences for the desired key-presses that
emacs is expecting. A writeup for how to fix some of these key bindings in Mac OS iterm2 is discussed
[[https://emacs.stackexchange.com/a/45624][here]]. The decimal ASCII codes to be used for whatever bindings
are desired can be looked up in any standard ASCII table.

For example, to map =C-,= in *iterm2* so that it works when emacs is run in console mode, I
configured my iterm2 profile to map =^,= to the escape sequence =[44;5u= since comma is ASCII code 44.
*** Disable 'cl is deprecated warning'
Stupid warning is shown because =cl= is a transitive dependency from other packages. Nothing we can
do until those packages migrate to something other than cl, so we'll just suppress the warning. See [[https://github.com/kiwanami/emacs-epc/issues/35][this]].
#+begin_src emacs-lisp
  (setq byte-compile-warnings '(cl-functions))
#+end_src
*** Save clipboard strings into kill ring before replacing them
   When one selects something in another program to paste it into Emacs, but kills something in
   Emacs before actually pasting it, this selection is gone unless this variable is non-nil.
   #+begin_src emacs-lisp
    (setq save-interprogram-paste-before-kill t)
   #+end_src
*** Save place in opened files
   When you visit a file, point goes to the last place where it was when you previously visited the
   same file. See [[https://www.emacswiki.org/emacs/SavePlace][here]].
   #+begin_src emacs-lisp
    (save-place-mode 1)
   #+end_src
*** Hippie expand
   [[https://www.emacswiki.org/emacs/HippieExpand][hippie-expand]] is a useful built-in function that does abbreviation or word expansion in a
   buffer. Activate it by invoking =M-/= (this overrides the keybinding for =dabbrev-expand=).
   #+begin_src emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand)
   #+end_src
   Also set some locations for =hippie-expand= to look for completions that are particularly
   useful for editing lisp files:
   #+begin_src emacs-lisp
    (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
   #+end_src
*** Regular Expression Builder
    =re-builder= is a built-in emacs major mode for interactively building Regular Expressions. Set
    the regexp syntax support to the better *string* syntax setting that prevents the need for
    escaping so many backslashes.
    #+begin_src emacs-lisp
      (require 're-builder)
      (setq reb-re-syntax 'string)
    #+end_src
*** Toggle whitespace-mode
    =whitespace-mode= is useful for showing whitespace characters on the screen. Togging it on or
    off using =C-c w=.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w") 'whitespace-mode)
#+end_src
* UI Customizations
*** Set geometry of all emacs frames on Mac
Top-left corner of initial frame will be 50 pixels down from the top margin and 250 pixels right from the left margin. It also makes the window size 45 x 112 characters.
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((top . 0) (left . 250) (width . 108) (height . 50)))
#+END_SRC
*** Font faces
Fonts are set in the =init.el= file rather than here, so that they can be customized using emacs
default =customize= functionality. The default font specified there, *Firas Code*, needs to be
downloaded separately. The following commands will do this on a Mac:
#+begin_example
  brew tap homebrew/cask-fonts
  brew install font-fira-code
#+end_example
*** Turn off graphical tool-bar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** Turn off native OS scroll bars on window frames
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode)
   (scroll-bar-mode -1))
#+END_SRC

*** Turn off top menu bar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC

*** Cursor blink
Set the cursor to always blink. This setting has no effect in TTY mode (the cursor is controlled
only by the terminal settings).
#+BEGIN_SRC emacs-lisp
  (setq blink-cursor-blinks 0)
#+END_SRC

*** Full path in title bar
   #+begin_src emacs-lisp
    (setq frame-title-format "%b (%f)")
   #+end_src
*** Turn on line numbering in all buffers that support it
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC
*** Beacon mode
Install and enable =beacon-mode= for better indicator when changing windows. See [[https://github.com/Malabarba/beacon][here]].
#+begin_src emacs-lisp
  (use-package beacon
    :ensure t
    :pin melpa-stable
    :init (beacon-mode 1)
    :diminish beacon-mode
    :custom
    (beacon-blink-when-window-scrolls nil))
#+end_src
*** Prettify Control L
    Emacs by default displays the form-feed (=C-l=) character as a literal "^L" character
    sequence. Since this is ugly, this package changes it to a horizonal line. The package used here
    is [[https://github.com/purcell/page-break-lines][page-break-lines]] because it works well with =dashboard-mode=. For some reason, it's not
    enabled globally for text modes, so we enable it.
    #+begin_src emacs-lisp
      (use-package page-break-lines
        :pin melpa-stable
        :ensure t
        :config (add-to-list 'page-break-lines-modes 'text-mode)
                (global-page-break-lines-mode)
        :diminish page-break-lines-mode)
    #+end_src
* Minibuffer
*** Install & use =smex= (from MELPA)
This package provides command completion using =ido= in the minibuffer after typing =M-x=.
#+BEGIN_SRC emacs-lisp
  (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind
       ("M-x" . smex))
#+END_SRC
*** Add =which-key= package
This package provides a pop-up menu of command key completions when keys are pressed interactively
in the minibuffer. We also suppress it from showing up in the modeline. See [[https://github.com/justbur/emacs-which-key][here]].
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode)
    :diminish which-key-mode)
#+END_SRC
* Mode Line
*** Turn on column mode display of (line,col) in mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
*** Spaceline
=spaceline= is a better mode line from the [[https://www.spacemacs.org/][spacemacs distribution]]. Use the spacemacs theme, but turn
off the file line-endings info segment in the mode line, which I don't find very useful.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :pin melpa-stable
    :ensure t
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme)
    (spaceline-toggle-buffer-encoding-abbrev-off))
#+END_SRC
*** Diminish minor modes from the modeline
    [[https://github.com/myrjola/diminish.el][diminish]] allows us to list the mode names that we don't want displayed in the modeline. We do
    that here by using the =:diminish= keyword in =use-package= declarations that we want to
    suppress, or by specifing them in the =config:= section.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :pin melpa-stable
    :ensure t
    :config (diminish 'eldoc-mode))
#+END_SRC

* Kill Ring
*** Turn on helpful kill ring pop-up menu and bind it to =M-y=
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Terminal
*** Make bash the default shell for ansi-term
    =bash= command will be located based on the =PATH= in the user's environment.
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
*** Bind ansi-term command
    to =s-t=
Doesn't work in tty mode, must use =C-x @ s t=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-t") 'ansi-term)
#+END_SRC
*** Turn off line numbers for shell terminals
    #+begin_src emacs-lisp
      (add-hook 'term-mode-hook (lambda () (display-line-numbers-mode 0)))
    #+end_src
* Org Mode
See [[https://orgmode.org/index.html][org-mode]].
*** Disable =org-mode= keybindings
These keybindings interfere with some I define below when emacs is in =org-mode=, so disable them
because I don't use the org-mode functions they are tied to much.
 #+begin_src emacs-lisp
   (eval-after-load 'org
     (progn
       (define-key org-mode-map (kbd "<C-S-right>") nil)
       (define-key org-mode-map (kbd "<C-S-left>") nil)
       (define-key org-mode-map (kbd "<C-S-up>") nil)
       (define-key org-mode-map (kbd "<C-S-down>") nil)))
 #+end_src
*** Edit src snippets in same window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
*** Htmlize
Install =htmlize= package to allow exporting =org-mode= files in html format
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t
    :defer t
    :pin melpa-stable)
#+END_SRC
*** Source snippet for emacs-lisp
In =org-mode=, the key combination =C-c C-, el= will insert an *emacs-lisp* block.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
              '( "el" . "src emacs-lisp"))
#+END_SRC
*** Presentations
[[https://github.com/takaxp/org-tree-slide][org-tree-slide]] mode can be used to create an interactive slide show in =org-mode=. To start a
presentation, do =M-x org-tree-slide-mode=.
#+begin_src emacs-lisp
  (use-package org-tree-slide
    :ensure t
    :defer t
    :pin melpa-stable
    :custom
    (org-tree-slide-in-effect t)
    (org-tree-slide-activate-message "presentation started")
    (org-tree-slide-deactivate-message "presentation ended")
    (org-tree-slide-header t)
    (org-tree-slide-breadcrumbs " // ")
    (org-image-actual-width nil)
    (org-tree-slide-simple-profile))
#+end_src
* Ido Mode
[[https://www.gnu.org/software/emacs/manual/html_mono/ido.html][ido-mode]] is a built-in minor mode that lets you "interactively do" things & makes the minibuffer
and most completion buffer features work better. It replaces many default emacs keybindings with new
ido-enabled functions that do similar things.
*** Enable =ido-mode=
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
#+END_SRC
*** Set some default preferences
#+BEGIN_SRC emacs-lisp
  (ido-everywhere t)
  (setq ido-use-faces t)
  (setq ido-create-new-buffer 'always)
  (setq ido-use-filename-at-point nil)
#+END_SRC
*** Install & use =ido-vertical-mode=
This package makes the IDO mode completions in the minibuffer vertical rather than the default horizontal.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init (setq ido-vertical-define-keys 'C-n-and-C-p-only)
    (ido-vertical-mode 1))
#+END_SRC
* Dired
For directory editing & file system operations within emacs.
*** Enable =dired-x=
Extensions for =dired-mode= that are pre-installed, but not enabled by default, so enable them. For
example, to open all marked files in a dired buffer, type *F* (shift-f).
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-load-hook (lambda () (load "dired-x")))
#+END_SRC
Force isearch operations in dired buffers to only search in filenames.
#+begin_src emacs-lisp
  (setq dired-isearch-filenames t)
#+end_src
* Config edit/reload
*** Edit this config file
Define a custom function to do this.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
*** Reload configs on demand
Define a custom function to do this.
#+BEGIN_SRC emacs-lisp
    (defun config-reload ()
      (interactive)
      (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC
* Moving Point
*** Move the point to where I really mean to (MWIM)
This package overrides the default beginning/end of line motion actions to more convenient
motion actions for programming modes. It's always on, so hopefully it doesn't interfere with
non-programming modes too much.
#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :ensure t
    :pin melpa-stable
    :bind (("C-a" . mwim-beginning)
     ("C-e" . mwim-end)))
#+END_SRC

*** Go To Last Change
Use the =C-x C-/= key combination to return to the last edit location in the active buffer.
#+BEGIN_SRC emacs-lisp
  (use-package goto-last-change
    :ensure t
    :pin melpa-stable
    :bind ("C-x C-/" . goto-last-change))
#+END_SRC

* Line Manipulation
*** Copy whole line
Copy the line containing the point to the kill ring.
#+BEGIN_SRC emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
  (point-at-bol)
  (point-at-eol)))))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'copy-whole-line)
#+END_SRC

* Buffers
*** Bind =ibuffer= to the normal buffer list key
ibuffer is a /better/ interactive buffer list that allows deleting buffers and switching buffers in the same window.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
*** Buffer Move
Package =buffer-move= allows re-arranging buffers within multiple windows in a frame. The
keybindings below conflict with =org-mode=, but they are too damn convenient, so just use
them when not in =org-mode=. "<C-S->" here means Ctrl+Shift+whatever.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :pin melpa-stable
    :bind (("<C-S-up>" . buf-move-up)
     ("<C-S-down>" . buf-move-down)
     ("<C-S-right>" . buf-move-right)
     ("<C-S-left>" . buf-move-left)))
#+END_SRC
*** Always kill the current buffer
Override default emacs and =ido-mode= functionality to prompt for the buffer to kill, and just go
ahead and kill the current one. It will still prompt for confirmation if the buffer is unsaved.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+END_SRC
Bind it to the default =kill-buffer= keybinding =C-x k=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill all buffers
This command will kill all killable buffers. If any buffers have unsaved changes, you'll be prompted
to confirm.
#+BEGIN_SRC emacs-lisp
  (defun kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
#+END_SRC
Bind it to some difficult key combination to press by accident: =C-M-s-k=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-s-k") 'kill-all-buffers)
#+END_SRC
* Windows
*** Split window horizontally & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split horizontally key =C-x 2=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
#+END_SRC
*** Split window vertically & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split vertically key =C-x 3=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
*** Halve other window height
    Tip from [[https://stackoverflow.com/questions/4987760/how-to-change-size-of-split-screen-emacs-windows][here]].
#+BEGIN_SRC emacs-lisp
  (defun halve-other-window-height ()
    "Expand current window to use half of the other window's lines."
    (interactive)
    (enlarge-window (/ (window-height (next-window)) 2)))
#+END_SRC
Bind it to a key.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c v") 'halve-other-window-height)
#+END_SRC
*** Bind more convenient keys to resize windows
*Note:* These override the default bindings for scroll window up/down, etc., but I don't care
because I use =C-v=, =M-v= for that. The arrow keys on Mac keyboards are given in comments next to
each definition below.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<next>") 'shrink-window) ; Fn-down-arrow
  (global-set-key (kbd "<prior>") 'enlarge-window) ; Fn-up-arrow
  (global-set-key (kbd "<home>") 'shrink-window-horizontally) ; Fn-left-arrow
  (global-set-key (kbd "<end>") 'enlarge-window-horizontally)  ; Fn-rigt-arrow
#+END_SRC
*** Buffer Move
=buffer-move= is a package that allows buffers to be rotated and moved when multiple windows are
open. Require it here and set some keybindings.
#+begin_src emacs-lisp
  (use-package buffer-move
    :ensure t
    :pin melpa-stable
    :bind (("<C-S-up>" . buf-move-up)
             ("<C-S-down>" . buf-move-down)
             ("<C-S-left>" . buf-move-left)
             ("<C-S-right>" . buf-move-right)))
#+end_src
* Frames
The functions in this section where excerpted from the [[https://www.emacswiki.org/emacs/frame-cmds.el][frame-cmds]] Emacs Wiki library.
*Note:* These keybindings use /<super>+<shift>/ key combinations.
*** Enlarge Frame Vertically
Makes the current frame vertically bigger incrementally.
#+begin_src emacs-lisp
  (defun enlarge-frame (&optional increment frame)
    "Increase the height of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in lines (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-height frame (+ (frame-height frame) increment)))

  (global-set-key (kbd "s-?") 'enlarge-frame)
#+end_src
*** Enlarge Frame Horizontally
Makes the current frame horizontally bigger incrementally.
#+begin_src emacs-lisp
  (defun enlarge-frame-horizontally (&optional increment frame)
    "Increase the width of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in columns (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-width frame (+ (frame-width frame) increment)))

  (global-set-key (kbd "s->") 'enlarge-frame-horizontally)
#+end_src
*** Shrink Frame Vertically
Makes the current frame vertically smaller incrementally.
#+begin_src emacs-lisp
  (defun shrink-frame (&optional increment frame)
    "Decrease the height of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in lines (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-height frame (- (frame-height frame) increment)))
  ;;; Bind to <super> + <shift> + M
  (global-set-key (kbd "s-M") 'shrink-frame)
#+end_src
*** Shrink Frame Horizontally
Makes the current frame horizontally smaller incrementally.
#+begin_src emacs-lisp
  (defun shrink-frame-horizontally (&optional increment frame)
    "Decrease the width of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in columns (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-width frame (- (frame-width frame) increment)))

  (global-set-key (kbd "s-<") 'shrink-frame-horizontally)
#+end_src
*** Double Frame Width
Makes the current frame twice as wide. I wrote this.
#+begin_src emacs-lisp
  (defun double-frame-width (&optional frame)
    "Double the width of FRAME (default: selected-frame)."
    (interactive)
    (set-frame-width frame (* (frame-width frame) 2)))

   (global-set-key (kbd "s-}") 'double-frame-width)
#+end_src
*** Halve Frame Width
Makes the current frame half as wide. I wrote this.
#+begin_src emacs-lisp
  (defun halve-frame-width (&optional frame)
    "Halve the width of FRAME (default: selected-frame)."
    (interactive)
    (set-frame-width frame (/ (frame-width frame) 2)))

  (global-set-key (kbd "s-{") 'halve-frame-width)
#+end_src
* Text Mode
*** =text-mode=
In text mode, you generally want to auto-wrap or "auto-fill" lines of text, so this makes that
happen but only in =text-mode= and its derivatives. We also enable =flyspell-mode= minor mode in all
text modes to get spellchecking functionality, and we bind =M-s= to the go to character function in
the =avy= package (because we don't want to use =avy= in non-text modes).

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda () (turn-on-auto-fill)
            (flyspell-mode)
            (local-set-key (kbd "M-s") 'avy-goto-char)))
#+END_SRC
**** Note: This requires that the =ispell= program be installed in the path of the local system.
* XML Mode
*** Turn off flyspell
=nxml-mode= is the modern major mode for editing xml structured documents. It inherits from
=text-mode=, so turning off =flyspell-mode= in order to get completion at point functionality.
#+begin_src emacs-lisp
  (add-hook 'nxml-mode-hook (lambda () (flyspell-mode 0)))
#+end_src
*** Prettify
This creates a keyboard macro that "prettifies" (i.e. re-indents and refomats) XML documents. To run
it, enter =M-x xml-prettify=.
*Note:* This command requires that the *xmllint* command is installed and available in the local
PATH. It comes pre-installed as part of *libxml* on most Mac OS systems.
#+begin_src emacs-lisp
  (defun xml-prettify ()
    (interactive)
    (shell-command-on-region
      (buffer-end 0)
      (buffer-end 1)
      "xmllint --format -"
      t
      t)
    )
#+end_src
* LaTeX
=LaTeX= mode comes built-in to emacs as a major mode that is automatically active for files ending
with =.tex= and that have =LaTeX= specific header information in them.

The =latex= command to create a =.dvi= file can be invoked on a buffer with the *tex-buffer* =C-c C-b=
command. The subsequent =.dvi= file can be converted to =.pdf= by using the *tex-view* =C-c C-v=
command. Here we configure *tex-view* to convert to PDF format.
#+begin_src emacs-lisp
  (setq tex-dvi-view-command "pdflatex")
  (setq tex-print-file-extension ".pdf")
#+end_src

* Programming Modes
*** =prog-mode= hook
The parent major mode for all programming language modes is =prog-mode=. Here we add the
=subword-mode= minor mode to this mode, which will allow navigation by word commands to respect
camel-case words. In other words, camel-case boundaries of identifiers will form "word" boundaries
in all programming language files with this setting enabled. Also, turn on spell-checking in
comments and literal strings using =flyspell-prog-mode= (This requires that the =ispell= program be
installed in the path of the local system).

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
            (subword-mode 1)
            (diminish 'subword-mode)
            (flyspell-prog-mode)
            (diminish 'flyspell-mode)))
#+END_SRC

*** Auto-complete
For auto-complete in programming modes, we'll use the [[https://company-mode.github.io/][company package]].
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :pin gnu
    :hook (('prog-mode . company-mode)
     ('cider-repl-mode . company-mode)))
#+END_SRC

*** Turn on parenthesis matching mode
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** Paredit
This minor mode makes dealing with parenthesis and lisp expressions much easier. Here, we enable it
for some lisp major modes only. Also remap the s-expression /slurp/
and /barf/ commands to keybindings that work in both GUI and TTY.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :pin melpa-stable
    :hook ((clojure-mode
            emacs-lisp-mode
            scheme-mode
            cider-repl-mode) . enable-paredit-mode)
    :bind (("C-c )" . paredit-forward-slurp-sexp)
           ("C-c (" . paredit-backward-slurp-sexp)
           ("C-c M-)" . paredit-forward-barf-sexp)
           ("C-c M-(" . paredit-backward-barf-sexp)))
#+END_SRC

*** Colorful matching delimiters
This package changes the color of corresponding pairs of parenthesis and brackets. Here, we enable
it only in prog-mode and its descendants, and in =cider-repl-mode=.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :pin melpa-stable
    :hook (('prog-mode . rainbow-delimiters-mode-enable)
     ('cider-repl-mode . rainbow-delimiters-mode-enable))
    )
#+END_SRC

* Clojure
In addition to the above settings, the following settings apply only to editing clojure files and buffers.
*** Set indent mode for clojure buffers
Set the variable =clojure-indent-style= to the value =always-indent=. See [[https://github.com/clojure-emacs/clojure-mode#indentation-options][here]] for more info.
#+BEGIN_SRC emacs-lisp
  (setq clojure-indent-style 'always-indent)
#+END_SRC
*** =clojure-mode= customizations
- =comment-column= set to 0 to not force adding extra space after inline *;*
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook (lambda () (setq-local comment-column 0)))
#+END_SRC

*** Install & use =cider= (from MELPA)
[[https://github.com/clojure-emacs/cider][cider]] is the /clojure integrated development environment/. We're only going to use the melpa stable version.
Initialize some settings, and bind the command to clear the REPL screen to =C-c C-l= key. Also set
the following defaults:
- =cider-repl-display-help-banner= suppress the verbose help banner when opened
- =cider-eldoc-display-context-dependent-info= try to auto-complete function calls with in-scope
  parameters
- =cider-allow-jack-in-without-project= Suppress warning that the REPL gives when you're current
  buffer is not part of a leiningen project.
- =nrepl-log-messages= Log all request/response messages between cider and the =nrepl= server to a
  special buffer for debugging purposes
- =cider-use-overlays= controls whether evaluated results are shown in the original
  buffer. Here, we disable in TTY mode, because the fonts & colors are messy. Results will be on the
  status line.
- =cider-prompt-for-symbol= Here, we set this variable to only prompt for the symbol if the lookup
  for the symbol at point fails.
- =cider-repl-pop-to-buffer-on-connect= Display the REPL buffer on connect, but don't move focus to
  it.
- =cider-repl-wrap-history= Wrap when navigating history.
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :pin melpa-stable
    :init (setq cider-repl-display-help-banner nil)
    (setq cider-eldoc-display-context-dependent-info t)
    (setq cider-allow-jack-in-without-project t)
    (setq nrepl-log-messages t)
    (setq cider-repl-result-prefix "=> ")
    (unless window-system (setq cider-use-overlays nil))
    (setq cider-prompt-for-symbol nil)
    (setq cider-repl-pop-to-buffer-on-connect 'display-only)
    (setq cider-repl-wrap-history t)
    :bind ("C-c C-l" . cider-repl-clear-buffer))
#+END_SRC

*** =cider-repl-mode=
Major mode for the Cider REPL. Enable subword mode in it, but diminish it.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-repl-mode-hook (lambda ()
            (subword-mode 1)
            (diminish 'subword-mode)))
#+END_SRC
* Scheme
*** Install & use =xscheme=
=xscheme= is a small, simple library that is recommended for interacting with the equally small and
simple *MIT scheme* implementation of the scheme language. Use of this library requires separate installation
of the MIT scheme interpreter binary, and the presence of that library in the PATH. It can be
installed on Mac OS with =brew install mit-scheme=.
#+begin_src emacs-lisp
  (require 'xscheme)
#+end_src
Define a function to start a scheme process in the current buffer. Run it with =M-x xscheme=.
#+begin_src emacs-lisp
  (defun scheme-repl ()
    "Starts a scheme process in new window next to the current window."
    (interactive)
    (let ((new-buff-name "*scheme*"))
      (switch-to-buffer-other-window new-buff-name)
      (xscheme-start "scheme -emacs"
                 new-buff-name
                 (get-buffer-create new-buff-name)))
    (reposition-window))
#+end_src
* Docker
*** Install & use =dockerfile-mode=
=dockerfile-mode= is a major mode helpful for editing Dockerfiles.
#+begin_src emacs-lisp
  (use-package dockerfile-mode
   :ensure t
   :defer t
   :pin melpa-stable)
#+end_src
* Git
*** Install & use =magit=
   =magit= is a major mode that provides a porcelain layer of tools for the =git= SCM. Map =C-c g=
   to a magit command that shows the current log (commits) for the file in the current
   buffer. Diminish the emacs built-in =auto-revert-mode= which gets enabled for files in git projects.
#+begin_src emacs-lisp
  (use-package magit
   :ensure t
   :defer t
   :pin melpa-stable
   :diminish auto-revert-mode
   :bind ("C-c g" . magit-log-buffer-file))
#+end_src
* Projects
*** Install & use =projectile=
  [[https://docs.projectile.mx/projectile/index.html][projectile]] is a major mode that allows for managing sets of files & buffers that constitute some
  type of /project/, such as git, maven, leiningen, etc. It can auto-discover these types of
  projects, or you can define them yourself. The functionality of searching by symbol is
  accomplished by the third-party tool =ctags=. It is recommended to install the better version of
  this than the one that ships with Emacs, called /Universal ctags/, which is available via
  homebrew, etc.
  #+begin_src emacs-lisp
    (use-package projectile
      :ensure t
      :diminish projectile-mode
      :pin melpa-stable
      :config (projectile-mode)
      :custom (projectile-switch-project-action #'projectile-dired)
              (projectile-mode-line-prefix "")
      :bind (:map projectile-mode-map
                  ("C-c p" . projectile-command-map)))
  #+end_src

* Diff
  Use built-in =ediff= for viewing and editing file differences. Bind the function to diff two files
  which are prompted for to a useful custom key (=C-c d=).
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c d") 'ediff-files)
  #+END_SRC
  Bind the function to diff to buffers to a custom key (=C-c b=).
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c b") 'ediff-buffers)
  #+end_src
  Put the "control panel" in the same frame as everything else.
  #+begin_src emacs-lisp
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  #+end_src
  Make ediff horizontally split the buffers to compare
  #+begin_src emacs-lisp
    (setq ediff-split-window-function 'split-window-horizontally)
  #+end_src

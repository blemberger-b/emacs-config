* Installation
Clone into the =.emacs.d= folder created by Emacs
#+BEGIN_SRC 
git clone https://github.com/blemberger-b/emacs-config.git ~/.emacs.d
#+END_SRC
When Emacs is opened, it will download the specified packages (with their dependencies) and
apply the customizations from *init.el* and this file.
* Installed Packages
These packages are installed via =use-package=
*** Install & run =exec-path-from-shell=
On OS X, an Emacs instance started from the graphical user interface will have a different
environment than a shell in a terminal window, because OS X does not run a shell during the login.
Obviously this will lead to unexpected results when calling external utilities like *make* from
Emacs. This library works around this problem by copying important environment variables from the
user's shell.
See https://github.com/purcell/exec-path-from-shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init (when (memq window-system '(mac ns x))
	    (exec-path-from-shell-initialize)))
#+END_SRC
*** Install & use =smex= (from MELPA)
This package provides command completion in the minibuffer after typing =M-x=.
#+BEGIN_SRC emacs-lisp
  (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind
       ("M-x" . smex))
#+END_SRC
*** Install & use =avy= (from MELPA)
This package provides a way to quickly go to a character in the visible buffer by typing =M-s=.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-char))
#+END_SRC
*** Install & use =sudo-edit= (from MELPA)
=sudo-edit= allows editing write protected files by first doing =sudo= before visting the file
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind ("s-e" . sudo-edit))
#+END_SRC
*** Dashboard
The =dashboard= package allows setting a better initial buffer when Emacs opens. See
https://github.com/emacs-dashboard/emacs-dashboard for info and configuration values. Also, here we
are excluding files from the recent files list that get treated as edited by the package manager for some reason.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :pin melpa-stable
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-items '((recents . 10)))
    (setq dashboard-banner-logo-title
	  "The more I learn about people, the more I like my dog\n\t\t\t\t\t\t\t\t\t--Mark Twain")
    (setq dashboard-set-footer nil)
    (setq recentf-exclude '(".*autoloads\.el" ".*\.gz")))
#+END_SRC
*** Go To Last Change
Use the =C-x C-/= key combination to return to the last edit location
#+BEGIN_SRC emacs-lisp
  (use-package goto-last-change
    :ensure t
    :pin melpa-stable
    :bind ("C-x C-/" . goto-last-change))
#+END_SRC
* Installed Modes
These modes are installed like packages via =use-package=
*** Add =which-key= package
This package provides a pop-up menu of command key completions when keys are pressed interactively
in the minibuffer. We also suppress it from showing up in the modeline. See https://github.com/justbur/emacs-which-key.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode)
    :diminish which-key-mode)
#+END_SRC
*** Install & use =markdown-mode= (from MELPA)
This package provides a major mode for editing markdown files. It requires the =markdown= command be installed via homebrew.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/markdown"))
#+END_SRC

*** Presentation Mode
This minor mode allows increasing/decreasing the font size in /all/ buffers. It can be run
on-demand: =M-x presentation-mode=. See https://github.com/zonuexe/emacs-presentation-mode.
#+BEGIN_SRC emacs-lisp
  (use-package presentation
    :ensure t
    :pin melpa-stable)
#+END_SRC
* Global Settings
*** Turn off emacs start screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Turn off aggressive vertical scrolling
#+BEGIN_SRC  emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

*** Turn off annoying bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Turn off auto-saving
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

*** Turn off stupid auto-backups
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

*** Set default fill column
Set the default column to 100 where emacs will attempt to auto-fill in those modes that support it.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 100)
#+END_SRC
*** Cursor blink
Set the cursor to always blink. This setting has no effect in TTY mode (the cursor always blinks
there).
#+BEGIN_SRC emacs-lisp
  (setq blink-cursor-blinks 0)
#+END_SRC

*** Replace 'yes-or-no' prompts everywhere with 'y-or-n' prompts
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Remap Mac Fn key to super key =(s- )=
Doesn't work in tty mode, must use =C-x @ s= and then the key.
#+BEGIN_SRC emacs-lisp
  (setq mac-function-modifier 'super)
#+END_SRC
*** Fix some stupid failed binding to =backtab= key in Mac OS console mode
See https://stackoverflow.com/questions/3518846/shift-tab-produces-cryptic-error-in-emacs.
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-setup-hook
	    (lambda () (define-key input-decode-map "\e[Z" [backtab])))
#+END_SRC

* UI Customizations
*** Set geometry of all emacs frames
Top-left corner of initial frame will be 50 pixels down from the top margin and 250 pixels right from the left margin. It also makes the window size 45 x 112 characters.
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((top . 50) (left . 250) (width . 112) (height . 45)))
#+END_SRC
*** Turn off graphical tool-bar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** Turn off right scroll-bar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
#+END_SRC

*** Turn off top menu bar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC

*** Turn on line numbering in all buffers that support it
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC

*** Turn on line highlight mode only in GUI mode
#+BEGIN_SRC emacs-lisp
  (when window-system (global-hl-line-mode))
#+END_SRC
* Mode Line
*** Turn on column mode display of (line,col) in mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
*** Spaceline
=spaceline= is a better mode line from the spacemacs distribution (https://www.spacemacs.org/)
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :pin melpa-stable
    :ensure t
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme))
#+END_SRC
*** Diminish minor modes from the modeline
    =diminish= allows us to list the mode names that we don't want displayed in the modeline. We do
    that here by using the =:diminish= keyword in =use-package= declarations that we want to
    suppress, or by specifing them in the =config:= section. See https://github.com/myrjola/diminish.el.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :pin melpa-stable
    :ensure t
    :config (diminish 'eldoc-mode))
#+END_SRC

* Kill Ring
*** Turn on helpful kill ring pop-up menu and bind it to =M-y=
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Terminal
*** Make bash the default shell for ansi-term
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
*** Bind ansi-term command to =s-t=
Doesn't work in tty mode, must use =C-x @ s t=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-t") 'ansi-term)
#+END_SRC
* Org Mode
*** Edit src snippets in same window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
*** Source snippet for emacs-lisp
In =org-mode=, the key combination =<el TAB= will insert an *emacs-lisp* block.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '( "el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
* IDO Mode
=ido-mode= is a built-in minor mode that makes the minibuffer and most completion buffer features
work better.
*** Enable =ido-mode=
#+BEGIN_SRC emacs-lisp
  (ido-mode 1)
#+END_SRC
*** Set some default preferences
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching nil)
  (setq ido-create-new-buffer 'always)
  (setq ido-everywhere t)
#+END_SRC
*** Install & use =ido-vertical-mode=
This package makes the IDO mode completions in the minibuffer vertical rather than the default horizontal.
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init (setq ido-vertical-define-keys 'C-n-and-C-p-only)
	  (ido-vertical-mode 1))
#+END_SRC
* Config edit/reload
*** Edit this config file
This function is bound to a key mapping above.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
*** Reload configs on demand
This function is bound to a key mapping above.
#+BEGIN_SRC emacs-lisp
    (defun config-reload ()
      (interactive)
      (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC
* Line Manipulation
*** Copy whole line
Copy the line containing the point to the kill ring.
#+BEGIN_SRC emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
#+END_SRC
Bind it to a key:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'copy-whole-line)
#+END_SRC

* Buffers
*** Bind =ibuffer= to the normal buffer list key
ibuffer is a /better/ interactive buffer list that allows deleting buffers and switching buffers in the same window.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
*** Buffer Move
Package =buffer-move= allows re-arranging buffers within multiple windows in a frame. The
keybindings below conflict with =org-mode=, but they are too damn convenient, so just use
them when not in =org-mode=. "<C-S->" here means Ctrl+Shift+whatever.
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :pin melpa-stable
    :bind (("<C-S-up>" . buf-move-up)
	   ("<C-S-down>" . buf-move-down)
	   ("<C-S-right>" . buf-move-right)
	   ("<C-S-left>" . buf-move-left)))
#+END_SRC
*** Always kill the current buffer
Override default emacs and =ido-mode= functionality to prompt for the buffer to kill, and just go
ahead and kill the current one. It will still prompt for confirmation if the buffer is unsaved.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+END_SRC
Bind it to the default =kill-buffer= keybinding =C-x k=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill all buffers
This command will kill all killable buffers. If any buffers have unsaved changes, you'll be prompted
to confirm.
#+BEGIN_SRC emacs-lisp
  (defun kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
#+END_SRC
Bind it to some difficult key combination to press by accident =C-M-s-k=
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-s-k") 'kill-all-buffers)
#+END_SRC
* Windows
*** Split window horizontally & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split horizontally key =C-x 2=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)
#+END_SRC
*** Split window vertically & put point in new window
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
#+END_SRC
Bind to the default split vertically key =C-x 3=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
*** Halve other window height
    Tip given at https://stackoverflow.com/questions/4987760/how-to-change-size-of-split-screen-emacs-windows.
#+BEGIN_SRC emacs-lisp
  (defun halve-other-window-height ()
    "Expand current window to use half of the other window's lines."
    (interactive)
    (enlarge-window (/ (window-height (next-window)) 2)))
#+END_SRC
Bind it to a key.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c v") 'halve-other-window-height)
#+END_SRC
*** Bind more convenient keys to resize windows
These only work in GUI mode in Mac OS.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-M-up>") 'shrink-window)
  (global-set-key (kbd "<C-M-down>") 'enlarge-window)
  (global-set-key (kbd "<C-M-left>") 'shrink-window-horizontally)
  (global-set-key (kbd "<C-M-right>") 'enlarge-window-horizontally)
#+END_SRC
* Text Mode
*** =text-mode=
In text mode, you generally want to auto-wrap or "auto-fill" lines of text, so this makes that
happen but only in =text-mode= and its derivatives. Also, enable =flyspell-mode= minor mode in all
text modes to get spellchecking functionality. 

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook (lambda () (turn-on-auto-fill)
			      (flyspell-mode)))
#+END_SRC
**** Note: This requires that the =ispell= program be installed in the path of the local system.
* Programming Modes
*** =prog-mode= hook
The parent major mode for all programming language modes is =prog-mode=. Here we add the =subword-mode= minor mode to
this mode, which will allow navigation by word commands to respect camel-case words. In other words, camel-case boundaries
of identifiers will form "word" boundaries in all programming language files with this setting
enabled. Also, turn on spell-checking in comments and literal strings using =flyspell-prog-mode= (This requires that the =ispell=
program be installed in the path of the local system).

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (lambda ()
			      (subword-mode 1)
			      (diminish 'subword-mode)
			      (flyspell-prog-mode)
			      (diminish 'flyspell-mode)))
#+END_SRC

*** Auto-complete
For auto-complete in programming modes, we'll use the =company= package (https://company-mode.github.io/).
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :pin gnu
    :hook (('prog-mode . company-mode)
	   ('cider-repl-mode . company-mode)))
#+END_SRC

*** Turn on parenthesis matching mode
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
*** Paredit
This minor mode makes dealing with parenthesis and lisp expressions much easier. Here, we enable it
for some lisp major modes only. Also remap the s-expression /slurp/
and /barf/ commands to keybindings that work in both GUI and TTY.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :pin melpa-stable
    :hook ((clojure-mode
	    emacs-lisp-mode
	    scheme-mode
	    geiser-repl-mode
	    cider-repl-mode) . enable-paredit-mode)
    :bind (("C-c )" . paredit-forward-slurp-sexp)
	   ("C-c (" . paredit-backward-slurp-sexp)
	   ("C-c M-)" . paredit-forward-barf-sexp)
	   ("C-c M-(" . paredit-backward-barf-sexp)))
#+END_SRC

*** Install & use =rainbow-delimiters= (from MELPA)
This package changes the color of corresponding pairs of parenthesis and brackets. Here, we enable
it only in prog-mode and its descendants, and in =cider-repl-mode=.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :pin melpa-stable
    :hook (('prog-mode . rainbow-delimiters-mode-enable)
	   ('cider-repl-mode . rainbow-delimiters-mode-enable))
    )
#+END_SRC

* Clojure
In addition to the above settings, the following settings apply only to editing clojure files and buffers.
*** Set indent mode for clojure buffers
Set the variable =clojure-indent-style= to the value =always-indent=. See
https://github.com/clojure-emacs/clojure-mode#indentation-options for more info.
#+BEGIN_SRC emacs-lisp
  (setq clojure-indent-style 'always-indent)
#+END_SRC
*** =clojure-mode= customizations
- =comment-add= only use one =;= when creating block clojure comments
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook (lambda () (setq-local comment-add 0)))
#+END_SRC
*** Install & use =cider= (from MELPA)
=cider= is the /clojure integrated development environment/
(https://github.com/clojure-emacs/cider). We're only going to use the melpa stable version.
Initialize the REPL to , and bind clear the REPL screen
to =C-c C-l= key. Also set the following defaults:
- =cider-repl-display-help-banner= suppress the verbose help banner when opened
- =cider-eldoc-display-context-dependent-info= try to auto-complete function calls with in-scope
  parameters
- =cider-allow-jack-in-without-project= Suppress warning that the REPL gives when you're current
  buffer is not part of a leiningen project.
- =nrepl-log-messages= Log all request/response messages between cider and the =nrepl= server to a
  special buffer for debugging purposes
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :pin melpa-stable
    :init (setq cider-repl-display-help-banner nil)
    (setq cider-eldoc-display-context-dependent-info t)
    (setq cider-allow-jack-in-without-project t)
    (setq nrepl-log-messages t)
    (setq cider-repl-result-prefix "=> ")
    :bind ("C-c C-l" . cider-repl-clear-buffer))
#+END_SRC

*** =cider-mode= used for .clj files
Configure clojure buffers (buffers tied to .clj files) to use =cider-mode= minor mode.
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook 'cider-mode)
#+END_SRC

*** =cider-repl-mode=
Major mode for the Cider REPL. Enable subword mode in it, but diminish it.
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-repl-mode-hook (lambda ()
			      (subword-mode 1)
			      (diminish 'subword-mode)))
#+END_SRC
* Scheme
*** Install & use =geiser=
=geiser= is a better scheme mode than the built-in =scheme-mode=. Specify =guile= command as the name of the scheme REPL
(https://www.gnu.org/software/guile/manual/html_node/index.html#SEC_Contents). =guile= can be
installed via *homebrew* or downloaded otherwise. The =guile= command must be included in the
*PATH*.

Start a scheme REPL by running the command =M-x run-geiser=.
#+BEGIN_SRC emacs-lisp
    (use-package geiser
      :ensure t
      :init (setq geiser-active-implementations '(guile))
      (setq geiser-repl-query-on-exit-p nil))
#+END_SRC
